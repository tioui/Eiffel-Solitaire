note
	description: "Responsible of creating visual images."
	author: "Louis Marchand"
	date: "Mon, 01 Aug 2016 21:17:25 +0000"
	revision: "0.1"

class
	IMAGE_FACTORY

inherit
	RESSOURCES_FACTORY
		rename
			make as make_ressource_factory
		undefine
			default_create
		end
	ERROR_MANAGER

create
	make

feature {NONE} -- Constants

	Images_Extension:STRING_32
			-- The extension of the image files
		once
			Result := {STRING_32}".png"
		end

	Fonts_Extension:STRING_32
			-- The extension of the font files
		once
			Result := {STRING_32}".ttf"
		end

feature {NONE} -- Initialization

	make(a_renderer:GAME_RENDERER; a_preference_directory:READABLE_STRING_GENERAL)
			-- Initialization of `Current' using `a_renderer' as `renderer'
		do
			default_create
			make_ressource_factory(a_preference_directory)
			renderer := a_renderer
			create default_pixel_format
			default_pixel_format.set_argb8888
			create default_image.make(renderer, default_pixel_format, 1, 1)
			common_cards := default_image
			load_common_cards("default")
			decks := default_image
			create {COLOR_BACKGROUND}board_background.make (create {GAME_COLOR}.make_rgb_from_hexadecimal ("000000"))
			menu_border := default_image
			menu_inside := default_image
			menu_select := default_image
			create menu_fonts.make (1)
			loaded_menu_font_name := ""
			load_board("default")
		end

feature -- Access

	load_common_cards(a_name:READABLE_STRING_GENERAL)
			-- Load a pack of cards from disk using the file name `a_name' (Must reload every {CARD} objects)
		do
			load_texture(Cards_directory + a_name, "cards")
			if attached last_loaded_texture as la_texture then
				common_cards := la_texture
			end
		end

	load_board(a_name:READABLE_STRING_GENERAL)
			-- Load the board from disk using the name `a_name' (Must reload every {BOARD} objects)
		do
			load_texture(Boards_directory + a_name, "decks")
			if attached last_loaded_texture as la_decks_texture then
				decks := la_decks_texture
			end
			load_background(a_name)
			load_texture(Boards_directory + a_name, "menu_inside")
			if attached last_loaded_texture as la_menu_inside_texture then
				menu_inside := la_menu_inside_texture
				load_texture(Boards_directory + a_name, "menu_border")
				if attached last_loaded_texture as la_menu_border_texture then
					menu_border := la_menu_border_texture
				end
			end
			loaded_menu_font_name := a_name
			load_texture(Boards_directory + a_name, "menu_select")
			if attached last_loaded_texture as la_menu_select_texture then
				menu_select := la_menu_select_texture
			end
		end

	menu_text:detachable GAME_TEXTURE
			-- The last text image generated by `get_menu_text'

	get_menu_text(a_text:READABLE_STRING_GENERAL; a_size:INTEGER)
			-- Generate a image from `a_text' using the loaded board font with the size `a_size'
		local
			l_surface:TEXT_SURFACE
		do
			menu_text := Void
			if attached menu_fonts.at (a_size) as la_font then
				create {TEXT_SURFACE_BLENDED}l_surface.make (a_text, la_font, menu_color)
				create menu_text.make_from_surface (renderer, l_surface)
			else
				load_font(Boards_directory + loaded_menu_font_name, "menu", a_size)
				if attached last_loaded_font as la_font then
					menu_fonts.extend (la_font, a_size)
					create {TEXT_SURFACE_BLENDED}l_surface.make (a_text, la_font, menu_color)
					create menu_text.make_from_surface (renderer, l_surface)
				end
			end
		end

	image_informations:detachable TUPLE[image:GAME_TEXTURE; sub_image_x, sub_image_y, sub_image_width, sub_image_height:INTEGER]
			-- The last image loaded, if any

	get_common_card(a_value, a_suit:INTEGER)
			-- Load the card identified with `a_value' and `a_suit' in `image_informations'
		local
			l_height, l_width:INTEGER
		do
			l_width := common_cards.width // 13
			l_height := common_cards.height // 5
			image_informations := [
									common_cards,
									(a_value - 1) * l_width,
									(a_suit - 1) * l_height,
									l_width,
									l_height
								]
		end

	get_common_card_back
			-- Load the back of a card in `image_informations'
		do
			get_common_card(3, 5)
		end

	default_image:GAME_TEXTURE
			-- A default image of 1x1 pixel

	default_pixel_format:GAME_PIXEL_FORMAT
			-- A {GAME_PIXEL_FORMAT} to used when creating {GAME_TEXTURE}

	board_background:BACKGROUND
			-- The {BACKGROUND} of the {BOARD} that has been loaded with `load_board'

	get_deck_standard
			-- Load the standard (empty) {DECK} indicator in `image_informations'
		do
			get_deck_by_index(1)
		end

	get_deck_heart
			-- Load the heart {DECK} indicator in `image_informations'
		do
			get_deck_by_index(2)
		end

	get_deck_diamond
			-- Load the diamond {DECK} indicator in `image_informations'
		do
			get_deck_by_index(3)
		end

	get_deck_club
			-- Load the club {DECK} indicator in `image_informations'
		do
			get_deck_by_index(4)
		end

	get_deck_spade
			-- Load the spade {DECK} indicator in `image_informations'
		do
			get_deck_by_index(5)
		end

	get_deck_reload
			-- Load the spade {DECK} indicator in `image_informations'
		do
			get_deck_by_index(6)
		end

	menu_inside:GAME_TEXTURE
			-- The background inside menus used in {MENU_ENGINE}


	get_menu_left
			-- Load into `image_informations' the left border of menus used in {MENU_ENGINE}
		do
			get_menu_border_by_index(4)
		end

	get_menu_right
			-- Load into `image_informations' the right border of menus used in {MENU_ENGINE}
		do
			get_menu_border_by_index(5)
		end

	get_menu_top
			-- Load into `image_informations' the top border of menus used in {MENU_ENGINE}
		do
			get_menu_border_by_index(2)
		end

	get_menu_bottom
			-- Load into `image_informations' the bottom border of menus used in {MENU_ENGINE}
		do
			get_menu_border_by_index(7)
		end

	get_menu_top_left
			-- Load into `image_informations' the top-left corner of menus used in {MENU_ENGINE}
		do
			get_menu_border_by_index(1)
		end

	get_menu_top_right
			-- Load into `image_informations' the top-right corner of menus used in {MENU_ENGINE}
		do
			get_menu_border_by_index(3)
		end

	get_menu_bottom_left
			-- Load into `image_informations' the bottom-left corner of menus used in {MENU_ENGINE}
		do
			get_menu_border_by_index(6)
		end

	get_menu_bottom_right
			-- Load into `image_informations' the bottom-right corner of menus used in {MENU_ENGINE}
		do
			get_menu_border_by_index(8)
		end

	get_menu_select_left
			-- Load into `image_informations' the left extremity of text selected indicator used in {MENU_ENGINE}
		do
			get_menu_select_by_index(1)
		end

	get_menu_select_center
			-- Load into `image_informations' the center part of text selected indicator used in {MENU_ENGINE}
		do
			get_menu_select_by_index(2)
		end

	get_menu_select_right
			-- Load into `image_informations' the right extremity of text selected indicator used in {MENU_ENGINE}
		do
			get_menu_select_by_index(3)
		end

	menu_color:GAME_COLOR
			-- The {GAME_COLOR} to used in menu
		do
			create Result.make_rgb(0, 0, 0)
		end

feature {NONE} -- Implementation

	load_image_informations(a_texture:GAME_TEXTURE; a_index, a_count:INTEGER)
			-- Load into `image_informations' the portion of `a_texture' specified by `a_index'
			-- when `a_texture' contain `a_count' images.
		local
			l_width:INTEGER
		do
			l_width := a_texture.width // a_count
			image_informations := [a_texture, (a_index - 1) * l_width, 0, l_width, a_texture.height]
		end


	get_deck_by_index(a_index:INTEGER)
			-- Load the {DECK} indicator having index `a_index' in `image_informations'
		do
			load_image_informations(decks, a_index, 6)
		end

	get_menu_border_by_index(a_index:INTEGER)
			-- Load in `image_informations' the portion of `menu_border' specified in `a_index'
		do
			load_image_informations(menu_border, a_index, 8)
		end

	get_menu_select_by_index(a_index:INTEGER)
			-- Load in `image_informations' the portion of `menu_select' specified in `a_index'
		do
			load_image_informations(menu_select, a_index, 3)
		end

	load_background(a_name:READABLE_STRING_GENERAL)
			-- Load the `board_background' from the file identified by `a_name'
		local
			l_preferences:PREFERENCES
			l_manager:PREFERENCE_MANAGER
			l_factory:BASIC_PREFERENCE_FACTORY
			l_value:STRING_32
		do
			create l_preferences.make_with_location (Boards_directory + a_name + "/board.xml")
			l_manager := l_preferences.new_manager ("boards")
			create l_factory
			l_value := l_factory.new_string_32_preference_value (l_manager, "background_type", {STRING_32}"").value
			if l_value ~ {STRING_32}"color" then
				load_color_background(l_preferences)
			elseif l_value.is_empty then
				set_error ("Error while reading Board informations. No Background Type found.")
			else
				set_error ("Error while reading Board informations. Background Type " + l_value + "is not valid.")
			end
		end

	load_color_background(a_preferences: PREFERENCES)
			-- Load a {COLOR_BACKGROUND} in the `board_background' using preferences `a_preferences'
		require
			Preferences_Manager_Exists: a_preferences.has_manager ("boards")
		local
			l_value:STRING_32
			l_factory:BASIC_PREFERENCE_FACTORY
		do
			if attached a_preferences.manager ("boards") as la_manager then
				create l_factory
				l_value := l_factory.new_string_32_preference_value (la_manager, "background_color", {STRING_32}"").value
				if not l_value.is_empty then
					create {COLOR_BACKGROUND}board_background.make (create {GAME_COLOR}.make_rgb_from_hexadecimal (l_value))
				else
					set_error ({STRING_32}"Cannot find the color of the board collored background.")
				end
			else
				set_error ({STRING_32}"Cannot load the color of the board collored background.")
			end
		end

	last_loaded_texture:detachable GAME_TEXTURE
			-- The {GAME_TEXTURE} loaded from `load_texture'

	load_texture(a_ressources_folder, a_image_name:READABLE_STRING_GENERAL)
			-- Load to `last_loaded_texture' the image from the file `a_image_name' into the ressources
			-- folder `a_ressources_name'.
		local
			l_image:IMG_IMAGE_FILE
		do
			last_loaded_texture := Void
			clear_error
			create l_image.make (a_ressources_folder + "/" + a_image_name + Images_Extension)
			if l_image.is_openable then
				l_image.open
				if l_image.is_open then
					create last_loaded_texture.make_from_image (renderer, l_image)
				else
					set_error ("The image " + a_ressources_folder + "/" + a_image_name + Images_Extension + " cannot be open - " + l_image.last_sdl_error)
				end
			else
				set_error ("The image " + a_ressources_folder + "/" + a_image_name + Images_Extension + " cannot be open")
			end
		end

	last_loaded_font:detachable TEXT_FONT
			-- The {TEXT_FONT} loaded from `load_font'

	load_font(a_ressources_folder, a_font_name:READABLE_STRING_GENERAL; a_size:INTEGER)
			-- Load to `last_loaded_font' the {TEXT_FONT} from the file `a_font_name' into the ressources
			-- folder `a_ressources_name' using the font size `a_size'.
		local
			l_font:TEXT_FONT
		do
			last_loaded_font := Void
			clear_error
			create l_font.make (a_ressources_folder + "/" + a_font_name + Fonts_Extension, a_size)
			if l_font.is_openable then
				l_font.open
				if l_font.is_open then
					last_loaded_font := l_font
				else
					set_error ("The font file " + a_ressources_folder + "/" + a_font_name + Fonts_Extension + " cannot be open - " + l_font.last_error)
				end
			else
				set_error ("The font file " + a_ressources_folder + "/" + a_font_name + Fonts_Extension + " cannot be open")
			end
		end

	renderer:GAME_RENDERER
			-- The game window renderer

	common_cards:GAME_TEXTURE
			-- The image of every common cards

	decks:GAME_TEXTURE
			-- The image of every {DECK} indicator

	menu_border:GAME_TEXTURE
			-- The image of every border of menus used in {MENU_ENGINE}

	menu_select:GAME_TEXTURE
			-- The image of selected text indicator used in {MENU_ENGINE}

	menu_fonts:HASH_TABLE[TEXT_FONT,INTEGER]
			-- Every {TEXT_FONT} used in menus

	loaded_menu_font_name:READABLE_STRING_GENERAL
			-- The name of the loaded font

invariant

note
	license: "[
		    Copyright (C) 2016 Louis Marchand

		    This program is free software: you can redistribute it and/or modify
		    it under the terms of the GNU General Public License as published by
		    the Free Software Foundation, either version 3 of the License, or
		    (at your option) any later version.

		    This program is distributed in the hope that it will be useful,
		    but WITHOUT ANY WARRANTY; without even the implied warranty of
		    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		    GNU General Public License for more details.

		    You should have received a copy of the GNU General Public License
		    along with this program.  If not, see <http://www.gnu.org/licenses/>.
		]"

end
